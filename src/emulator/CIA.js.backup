// FIX 1: Update CIA.js with working keyboard implementation
// CIA.js - Replace the typeChar and add keyboard processing

export class CIA {
    constructor(chipNumber, memory) {
        this.chipNumber = chipNumber;
        this.memory = memory;
        this.registers = new Uint8Array(16);
        
        // Timer A and B
        this.timerA = 0xFFFF;
        this.timerB = 0xFFFF;
        this.timerALatch = 0xFFFF;
        this.timerBLatch = 0xFFFF;
        this.timerARunning = false;
        this.timerBRunning = false;
        
        // Keyboard matrix (CIA 1) - 8x8 matrix
        this.keyMatrix = new Uint8Array(8);
        this.keyMatrix.fill(0xFF); // No keys pressed
        
        // For CIA1: Keyboard queue
        this.keyQueue = [];
        
        // Joystick state
        this.joystickState = {
            up: false,
            down: false,
            left: false,
            right: false,
            fire: false
        };
        
        // Interrupt
        this.onIRQ = null;
        this.onNMI = null;
    }
    
    reset() {
        this.registers.fill(0);
        this.timerA = 0xFFFF;
        this.timerB = 0xFFFF;
        this.timerARunning = false;
        this.timerBRunning = false;
        this.keyQueue = [];
    }
    
    // This needs to be called every frame!
    processKeyboard() {
        if (this.chipNumber !== 1) return; // Only CIA1 handles keyboard
        
        // Check if we have keys to process
        if (this.keyQueue.length > 0) {
            // Get current buffer index
            let bufferCount = this.memory.read(0x00C6);
            
            // Process keys while buffer has room (max 10 chars)
            while (this.keyQueue.length > 0 && bufferCount < 10) {
                const key = this.keyQueue.shift();
                
                // Write to keyboard buffer at $0277
                this.memory.write(0x0277 + bufferCount, key);
                bufferCount++;
                
                // Update buffer count
                this.memory.write(0x00C6, bufferCount);
                
                // Signal that a key is available
                this.memory.write(0x00CB, 0x7F); // Key pressed flag
                
                console.log(`Added key to buffer: 0x${key.toString(16)} at position ${bufferCount-1}`);
            }
            
            // Trigger IRQ if we added keys
            if (bufferCount > 0 && this.onIRQ) {
                this.onIRQ();
            }
        }
    }
    
    typeChar(char) {
        if (this.chipNumber !== 1) return;
        
        // Convert to PETSCII and add to queue
        const petscii = this.charToPETSCII(char);
        this.keyQueue.push(petscii);
        
        console.log(`Queued char '${char}' as PETSCII 0x${petscii.toString(16)}`);
    }
    
    charToPETSCII(char) {
        const code = char.charCodeAt(0);
        
        // Special keys
        if (char === '\n' || char === '\r') return 0x0D; // RETURN
        if (char === ' ') return 0x20; // SPACE
        
        // Letters - C64 expects uppercase in buffer
        if (code >= 97 && code <= 122) { // a-z
            return code - 32; // Convert to uppercase
        }
        if (code >= 65 && code <= 90) { // A-Z
            return code; // Already uppercase
        }
        
        // Numbers and common symbols match ASCII
        if (code >= 32 && code <= 95) {
            return code;
        }
        
        return 0x20; // Default to space
    }
    
    read(address) {
        const reg = address & 0x0F;
        
        // CIA 1 - Keyboard and Joystick
        if (this.chipNumber === 1) {
            if (reg === 0x00) { // Port A - keyboard columns
                return 0xFF; // No keys pressed (for now)
            }
            if (reg === 0x01) { // Port B - keyboard rows / joystick
                let value = 0xFF;
                
                // Joystick in port 2 (CIA 1, Port B)
                if (!this.joystickState.up) value &= ~0x01;
                if (!this.joystickState.down) value &= ~0x02;
                if (!this.joystickState.left) value &= ~0x04;
                if (!this.joystickState.right) value &= ~0x08;
                if (!this.joystickState.fire) value &= ~0x10;
                
                return value;
            }
        }
        
        // Timer registers
        if (reg === 0x04) return this.timerA & 0xFF;
        if (reg === 0x05) return (this.timerA >> 8) & 0xFF;
        if (reg === 0x06) return this.timerB & 0xFF;
        if (reg === 0x07) return (this.timerB >> 8) & 0xFF;
        
        return this.registers[reg];
    }
    
    write(address, value) {
        const reg = address & 0x0F;
        this.registers[reg] = value;
        
        // Timer control
        if (reg === 0x0E) { // Control Register A
            if (value & 0x01) {
                this.timerARunning = true;
            }
            if (value & 0x10) { // Load timer
                this.timerA = this.timerALatch;
            }
        }
        
        // Timer latches
        if (reg === 0x04) this.timerALatch = (this.timerALatch & 0xFF00) | value;
        if (reg === 0x05) this.timerALatch = (this.timerALatch & 0x00FF) | (value << 8);
    }
    
    cycle(cycles) {
        // Update timers
        if (this.timerARunning) {
            this.timerA -= cycles;
            if (this.timerA <= 0) {
                this.timerA = this.timerALatch;
                // Trigger interrupt if enabled
                if (this.chipNumber === 1 && this.onIRQ) {
                    // Timer A underflow - trigger IRQ
                    // this.onIRQ(); // Commented out to avoid too many IRQs
                }
            }
        }
    }
    
    setJoystick(state) {
        this.joystickState = state;
    }
}
