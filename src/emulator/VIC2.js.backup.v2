// VIC2.js - VIC-II Video Interface Controller
// WORKING VERSION with console fixes merged

export class VIC2 {
    constructor(memory) {
        this.memory = memory;
        this.canvas = document.createElement('canvas');
        this.canvas.width = 384;  // Including border (320 + 64)
        this.canvas.height = 272;  // Including border (200 + 72)
        this.ctx = this.canvas.getContext('2d');
        this.imageData = this.ctx.createImageData(384, 272);
        
        // Screen dimensions
        this.screenWidth = 320;
        this.screenHeight = 200;
        this.borderWidth = 32;
        this.borderHeight = 36;
        
        // VIC-II state - FIXED: renamed from 'cycle' to 'cycleCounter'
        this.cycleCounter = 0;  // Current cycle in line
        this.rasterY = 0;       // Current raster line
        this.maxRasterY = 312;  // PAL: 312 lines
        this.cyclesPerLine = 63; // PAL: 63 cycles per line
        
        // Registers (0xD000-0xD02E)
        this.registers = new Uint8Array(64);
        
        // Sprites
        this.sprites = new Array(8).fill(null).map(() => ({
            enabled: false,
            x: 0, 
            y: 0,
            expandX: false, 
            expandY: false,
            multicolor: false,
            priority: false,
            color: 0
        }));
        
        // Colors - FIXED: using hex values that work
        this.palette = [
            0x000000, 0xFFFFFF, 0x880000, 0xAAFFEE,
            0xCC44CC, 0x00CC55, 0x0000AA, 0xEEEE77,
            0xDD8855, 0x664400, 0xFF7777, 0x333333,
            0x777777, 0xAAFF66, 0x0088FF, 0xBBBBBB
        ];
        
        // Graphics modes
        this.textMode = true;
        this.bitmapMode = false;
        this.multicolorMode = false;
        this.extendedColorMode = false;
        
        // Memory pointers
        this.screenMemory = 0x0400;  // Default screen memory
        this.charGenMemory = 0xD000; // Character generator ROM
        this.colorMemory = 0xD800;   // Color RAM
        
        // Initialize screen
        this.clearScreen();
    }
    
    clearScreen() {
        // Fill with border color (default light blue)
        const borderColor = this.palette[14];
        const data = this.imageData.data;
        
        for (let i = 0; i < data.length; i += 4) {
            data[i] = (borderColor >> 16) & 0xFF;     // R
            data[i + 1] = (borderColor >> 8) & 0xFF;  // G
            data[i + 2] = borderColor & 0xFF;         // B
            data[i + 3] = 255;                        // A
        }
        
        this.ctx.putImageData(this.imageData, 0, 0);
    }
    
    reset() {
        this.cycleCounter = 0;  // FIXED: using cycleCounter
        this.rasterY = 0;
        this.registers.fill(0);
        this.clearScreen();
        
        // Set default register values
        this.registers[0x11] = 0x1B; // Control register 1
        this.registers[0x16] = 0xC8; // Control register 2
        this.registers[0x18] = 0x14; // Memory pointers
        this.registers[0x20] = 0x0E; // Border color (light blue)
        this.registers[0x21] = 0x06; // Background color (blue)
    }
    
    setCanvas(externalCanvas) {
        // Use external canvas if provided, otherwise use internal
        if (externalCanvas) {
            this.canvas = externalCanvas;
            this.canvas.width = 384;  // Including border
            this.canvas.height = 272; // Including border
            this.ctx = this.canvas.getContext('2d');
            this.imageData = this.ctx.createImageData(384, 272);
            console.log('VIC2: Using external canvas');
        }
    }

    // FIXED cycle() method from console command that worked
    // cycle() {
    //     this.cycleCounter++;
        
    //     // End of line?
    //     if (this.cycleCounter >= this.cyclesPerLine) {
    //         this.cycleCounter = 0;
    //         this.rasterY++;
            
    //         // Render visible lines as we go (optional optimization)
    //         if (this.rasterY >= 50 && this.rasterY < 250) {
    //             // We're in the visible area
    //             if (this.rasterY === 50) {
    //                 // Start of visible area - clear screen once
    //                 if (this.ctx) {
    //                     // Draw border
    //                     this.drawBorder();
    //                 }
    //             }
    //         }
            
    //         // End of frame?
    //         if (this.rasterY >= this.maxRasterY) {
    //             this.rasterY = 0;
    //             // Render the complete frame
    //             this.renderFrame();
    //         }
            
    //         // Check for raster interrupt
    //         this.checkRasterIRQ();
    //     }
    // }
    cycle() {
    this.cycleCounter++;
    // console.log('this.cycleCounter:'+this.cycleCounter+ 'this.cyclesPerLine '+this.cyclesPerLine)
    // End of line?
    if (this.cycleCounter >= this.cyclesPerLine) {
        this.cycleCounter = 0;
        this.rasterY++;
        
        // End of frame?
        if (this.rasterY >= this.maxRasterY) {
            this.rasterY = 0;
            this.renderFrame();
        }
        
        // Check for raster interrupt
        this.checkRasterIRQ();
    }
}

    drawBorder() {
        const borderColor = this.palette[this.registers[0x20] & 0x0F];
        const data = this.imageData.data;
        
        // Top and bottom borders
        for (let y = 0; y < this.borderHeight; y++) {
            for (let x = 0; x < 384; x++) {
                // Top border
                let offset = (y * 384 + x) * 4;
                data[offset] = (borderColor >> 16) & 0xFF;
                data[offset + 1] = (borderColor >> 8) & 0xFF;
                data[offset + 2] = borderColor & 0xFF;
                
                // Bottom border
                offset = ((272 - this.borderHeight + y) * 384 + x) * 4;
                data[offset] = (borderColor >> 16) & 0xFF;
                data[offset + 1] = (borderColor >> 8) & 0xFF;
                data[offset + 2] = borderColor & 0xFF;
            }
        }
        
        // Left and right borders
        for (let y = this.borderHeight; y < 272 - this.borderHeight; y++) {
            for (let x = 0; x < this.borderWidth; x++) {
                // Left border
                let offset = (y * 384 + x) * 4;
                data[offset] = (borderColor >> 16) & 0xFF;
                data[offset + 1] = (borderColor >> 8) & 0xFF;
                data[offset + 2] = borderColor & 0xFF;
                
                // Right border
                offset = (y * 384 + (384 - this.borderWidth + x)) * 4;
                data[offset] = (borderColor >> 16) & 0xFF;
                data[offset + 1] = (borderColor >> 8) & 0xFF;
                data[offset + 2] = borderColor & 0xFF;
            }
        }
    }

    // FIXED renderFrame() from working console command
    // renderFrame() {
    //     if (!this.ctx) {
    //         this.ctx = document.getElementById('screen').getContext('2d');
    //         this.canvas = document.getElementById('screen');
    //     }
        
    //     // C64 colors
    //     const colors = [
    //         0x000000, 0xFFFFFF, 0x880000, 0xAAFFEE,
    //         0xCC44CC, 0x00CC55, 0x0000AA, 0xEEEE77,
    //         0xDD8855, 0x664400, 0xFF7777, 0x333333,
    //         0x777777, 0xAAFF66, 0x0088FF, 0xBBBBBB
    //     ];
        
    //     // Get screen settings
    //     const borderColor = colors[this.registers[0x20] & 0x0F] || colors[14];
    //     const bgColor = colors[this.registers[0x21] & 0x0F] || colors[6];
    //     const screenMemory = ((this.registers[0x18] & 0xF0) >> 4) * 0x400;
        
    //     // Clear with border color
    //     this.ctx.fillStyle = '#' + borderColor.toString(16).padStart(6, '0');
    //     this.ctx.fillRect(0, 0, 384, 272);
        
    //     // Draw background
    //     this.ctx.fillStyle = '#' + bgColor.toString(16).padStart(6, '0');
    //     this.ctx.fillRect(32, 35, 320, 200);
        
    //     // Simple character patterns for READY.
    //     const charPatterns = {
    //         0x01: [0x18,0x3C,0x66,0x7E,0x66,0x66,0x66,0x00], // A
    //         0x04: [0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00], // D  
    //         0x05: [0x7E,0x60,0x60,0x78,0x60,0x60,0x7E,0x00], // E
    //         0x12: [0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00], // R
    //         0x19: [0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00], // Y
    //         0x2E: [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00]  // .
    //     };
        
    //     // Render text characters
    //     for (let row = 0; row < 25; row++) {
    //         for (let col = 0; col < 40; col++) {
    //             const charIndex = row * 40 + col;
    //             const screenCode = this.memory.read(screenMemory + charIndex);
                
    //             if (screenCode !== 0x20 && screenCode !== 0x00) {
    //                 const colorCode = this.memory.read(0xD800 + charIndex) & 0x0F;
    //                 const color = colors[colorCode || 14];
    //                 this.ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
                    
    //                 // Get pattern or use default
    //                 const pattern = charPatterns[screenCode] || [0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF];
                    
    //                 // Draw character
    //                 for (let cy = 0; cy < 8; cy++) {
    //                     const bits = pattern[cy];
    //                     for (let cx = 0; cx < 8; cx++) {
    //                         if (bits & (0x80 >> cx)) {
    //                             this.ctx.fillRect(
    //                                 32 + col * 8 + cx,
    //                                 35 + row * 8 + cy,
    //                                 1, 1
    //                             );
    //                         }
    //                     }
    //                 }
    //             }
    //         }
    //     }
    // }

    renderFrame() {
        if (!this.ctx) {
            this.ctx = this.canvas.getContext('2d');
        }
        
        // Draw border
        this.drawBorder();
        
        // Determine graphics mode
        const ctrl1 = this.registers[0x11];
        this.textMode = !(ctrl1 & 0x20);
        this.bitmapMode = !!(ctrl1 & 0x20);
        
        if (this.textMode) {
            this.renderTextMode();
        }
        
        // Update sprites
        this.updateSprites();
        
        // Put the image data to canvas
        this.ctx.putImageData(this.imageData, 0, 0);
    }
    renderTextMode() {
        const screenMemory = ((this.registers[0x18] & 0xF0) >> 4) * 0x400;
        const data = this.imageData.data;
        
        // Colors
        const borderColor = this.palette[this.registers[0x20] & 0x0F];
        const bgColor = this.palette[this.registers[0x21] & 0x0F];
        
        // Fill background
        for (let y = this.borderHeight; y < 272 - this.borderHeight; y++) {
            for (let x = this.borderWidth; x < 384 - this.borderWidth; x++) {
                const offset = (y * 384 + x) * 4;
                data[offset] = (bgColor >> 16) & 0xFF;
                data[offset + 1] = (bgColor >> 8) & 0xFF;
                data[offset + 2] = bgColor & 0xFF;
                data[offset + 3] = 255;
            }
        }
        
        // Simple character patterns for READY.
        const patterns = {
            0x01: [0x18,0x3C,0x66,0x7E,0x66,0x66,0x66,0x00], // A
            0x04: [0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00], // D
            0x05: [0x7E,0x60,0x60,0x78,0x60,0x60,0x7E,0x00], // E
            0x12: [0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x00], // R
            0x19: [0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00], // Y
            0x2E: [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00]  // .
        };
        
        // Render text characters (40x25)
        for (let row = 0; row < 25; row++) {
            for (let col = 0; col < 40; col++) {
                const charIndex = row * 40 + col;
                const screenCode = this.memory.read(screenMemory + charIndex);
                
                // Skip spaces
                if (screenCode === 0x20 || screenCode === 0x00) continue;
                
                // Get color from color RAM
                const colorCode = this.memory.read(0xD800 + charIndex) & 0x0F;
                const color = this.palette[colorCode || 14];
                
                // Get pattern or use default block
                const pattern = patterns[screenCode] || [0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF];
                
                // Draw character
                for (let cy = 0; cy < 8; cy++) {
                    const charByte = pattern[cy];
                    for (let cx = 0; cx < 8; cx++) {
                        if (charByte & (0x80 >> cx)) {
                            const px = col * 8 + cx + this.borderWidth;
                            const py = row * 8 + cy + this.borderHeight;
                            const offset = (py * 384 + px) * 4;
                            
                            data[offset] = (color >> 16) & 0xFF;
                            data[offset + 1] = (color >> 8) & 0xFF;
                            data[offset + 2] = color & 0xFF;
                            data[offset + 3] = 255;
                        }
                    }
                }
            }
        }
    }
    
    updateSprites() {
        // Update sprite positions and properties from registers
        for (let i = 0; i < 8; i++) {
            const sprite = this.sprites[i];
            sprite.x = this.registers[i * 2] | ((this.registers[0x10] & (1 << i)) ? 0x100 : 0);
            sprite.y = this.registers[i * 2 + 1];
            sprite.enabled = !!(this.registers[0x15] & (1 << i));
            sprite.expandX = !!(this.registers[0x1D] & (1 << i));
            sprite.expandY = !!(this.registers[0x17] & (1 << i));
            sprite.multicolor = !!(this.registers[0x1C] & (1 << i));
            sprite.priority = !!(this.registers[0x1B] & (1 << i));
            sprite.color = this.registers[0x27 + i] & 0x0F;
            
            if (sprite.enabled) {
                this.drawSprite(i);
            }
        }
    }
    
    drawSprite(index) {
        // Simplified sprite drawing
        const sprite = this.sprites[index];
        // TODO: Implement full sprite rendering
    }
    
    checkRasterIRQ() {
        const rasterCompare = this.registers[0x12] | ((this.registers[0x11] & 0x80) << 1);
        if (this.rasterY === rasterCompare && (this.registers[0x1A] & 0x01)) {
            // Set raster interrupt flag
            this.registers[0x19] |= 0x01;
            // TODO: Trigger CPU IRQ
        }
    }
    
    read(address) {
        const reg = address & 0x3F;
        
        if (reg === 0x11) {
            // Include current raster line bit 8
            return (this.registers[reg] & 0x7F) | ((this.rasterY & 0x100) >> 1);
        } else if (reg === 0x12) {
            // Current raster line bits 0-7
            return this.rasterY & 0xFF;
        }
        
        return this.registers[reg];
    }
    
    write(address, value) {
        const reg = address & 0x3F;
        this.registers[reg] = value;
        
        // Handle special registers
        if (reg === 0x11) {
            // Control register 1
            this.textMode = !(value & 0x20);
            this.bitmapMode = !!(value & 0x20);
            this.extendedColorMode = !!(value & 0x40);
        } else if (reg === 0x16) {
            // Control register 2
            this.multicolorMode = !!(value & 0x10);
        } else if (reg === 0x18) {
            // Memory pointers
            this.screenMemory = ((value >> 4) & 0x0F) * 0x400;
            this.charGenMemory = ((value >> 1) & 0x07) * 0x800;
        }
    }
    
    getCanvas() {
        return this.canvas;
    }
}